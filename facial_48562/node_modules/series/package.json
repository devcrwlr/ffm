{
  "_args": [
    [
      {
        "raw": "series",
        "scope": null,
        "escapedName": "series",
        "name": "series",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\facial"
    ]
  ],
  "_from": "series@latest",
  "_id": "series@0.3.3",
  "_inCache": true,
  "_location": "/series",
  "_npmUser": {
    "name": "scottcorgan",
    "email": "scottcorgan@gmail.com"
  },
  "_npmVersion": "1.3.11",
  "_phantomChildren": {},
  "_requested": {
    "raw": "series",
    "scope": null,
    "escapedName": "series",
    "name": "series",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/series/-/series-0.3.3.tgz",
  "_shasum": "e76e7ccf2901e4e21a1a25732cf62fd98db8de3e",
  "_shrinkwrap": null,
  "_spec": "series",
  "_where": "C:\\facial",
  "author": {
    "name": "Scott Corgan"
  },
  "bugs": {
    "url": "https://github.com/scottcorgan/series/issues"
  },
  "dependencies": {
    "drainer": "~0.1.0",
    "promise": "~3.2.0"
  },
  "description": "Compose a series of chainable async methods",
  "devDependencies": {
    "async": "~0.2.9",
    "expect.js": "~0.2.0",
    "mocha": "~1.14.0",
    "sinon": "~1.7.3"
  },
  "directories": {},
  "dist": {
    "shasum": "e76e7ccf2901e4e21a1a25732cf62fd98db8de3e",
    "tarball": "https://registry.npmjs.org/series/-/series-0.3.3.tgz"
  },
  "homepage": "https://github.com/scottcorgan/series#readme",
  "keywords": [
    "chain",
    "async",
    "compose"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "scottcorgan",
      "email": "scottcorgan@gmail.com"
    }
  ],
  "name": "series",
  "optionalDependencies": {},
  "readme": "# Series\n\nCompose a series of chainable async methods. Supports callbacks AND promises.\n\nSupports Node and [Browserify](http://browserify.org/)\n\n## Install\n\n```\nnpm install series --save\n```\n\n## Usage\n\n```js\nvar Series = require('series');\nvar series = Series();\nvar async = require('async'); // <~~ simply for usage example\n\n// Add methods to our series sequence\nseries.add('map', function (items, iterator, next) {\n  async.map(items, iterator, next);\n});\n\nseries.add('sortBy', function (items, iterator, next) {\n  async.sortBy(items, iterator, next);\n});\n\nseries.add('filter', function (items, iterator, next) {\n  var self = this;\n  var error;\n  \n  async.filter(items, function (item, callback) {\n    iterator(item, function (err, matched) {\n      if (err) {\n        error = err;\n        return;\n      }\n      \n      callback(matched);\n    });\n  }, function (filteredItems) {\n    next(error, filteredItems);\n  });\n});\n\n// Use our series\nvar list = [\n  {\n    name: 'John',\n    age: 25\n  },\n  {\n    name: 'Jane',\n    age: 20\n  }\n];\n\nseries(list)\n  .sortBy(function (item, next) {\n    next(null, item.age);\n  })\n  .map(function (item, next) {\n    next(null, item.age);\n  }, function (err, items) {\n    // Support for callbacks\n  })\n  .then(function (items) {\n    // items now equals: [20, 25]\n  }, function (err) {\n    // oops, an error may have occured\n  });\n```\n\n## series\n\nThe instance value returned from calling `Series()` is both a function and an object. The object is the instance and the function returns the series chain.\n\n`series()` supports the following as initial values to start the series:\n\n* **Primitive** - strings, numbers, etc.\n* **Array** - an array of primitives or objects\n* **Function** - a function that is passed a `next` callback that must be called with the following: `next(err, value)`. The value passed as the second argument becomes the initial value of the series.\n* **Promise** - a [ Promises/A+](http://promises-aplus.github.io/promises-spec/) compliant value\n\n###For example:\n\n**Primitive**\n\n```js\nvar Series = require('series');\nvar series = Series();\n\nvar someValue = 'my value';\nseries(someValue);\n```\n\n**Array**\n\n```js\nvar Series = require('series');\nvar series = Series();\n\nvar someValue = [1,2,3,4,5];\nseries(someValue);\n```\n\n**Function**\n\n```js\nvar Series = require('series');\nvar series = Series();\n\nseries(function (next) {\n  var someValue = 'my value';\n  next(null, someValue);\n});\n```\n\n**Promise**\n\n```js\nvar Series = require('series');\nvar Promise = require('promise'); // <~~ npm install promise \nvar series = Series();\n\nvar promise = new Promise(function (resolve, reject) {\n  // Some logic\n});\n\nseries(promise);\n```\n\n## instance methods\n\nThese methods are available on the `series` variable.\n\n### add(methodName, methodTask)\n\nComposes a chainable method on the series. The method is added for all instances of that particular series.\n\n**methodName**\n\nA string that will be used as the method name\n\n**methodTask**\n\nA callback function that is passed the following parameters\n\n* `items` - any value that you would like passed to the first method in the series\n* `iterator` - the method called on the value from the previous method that performs some sort of user defined operation\n* `next` - the callback once all items in the list or collection have been processed.\n\n#### For Example:\n\n```js\nvar Series = require('series');\nvar series = Series();\n\n// Add methods to our series sequence\nseries.add('map', function (items, iterator, next) {\n  iterator(items, function (err, processItems) {\n    next(err, processItems);\n  });\n});\n```\n\n## series sequence methods\n\nThese methods are available on the value returned from calling `series(someValue)`\n\nThe methods available vary according to which methods have been added to the series. In the usage example above, we've added `map`, `sortBy`, and `filter`. These methods would be available on the series as well as:\n\n### then(successCallback, errorCallback)\n\nEach series sequence returns a promise. Refer to the [Promises/A+](http://promises-aplus.github.io/promises-spec/) spec for more details.\n\n**successCallback**\n\nThis is called once all chained methods have processed the initial value, unless an error has occurred.\n\n**errorCallback**\n\nThis is called if an error occurs anywhere when processing the initial value in any of the chainable methods. If an error occurs, all processing stops.\n\n#### For Example:\n\n```js\nvar Series = require('series');\nvar series = Series();\n\nvar someValue = 'my value';\nseries(someValue)\n  .someChainableMethod(function (value, next) {\n    next(null, value + 's');\n  })\n  .then(function (processedValue) {\n    // processedValue == my values\n  });\n```\n\n## Callbacks\n\nEach method in the series can take a callback if you'd rather not use promises. Each callback will be called at the completion of each method.\n\n#### For Example:\n\n```js\nvar Series = require('series');\nvar series = Series();\n\nseries(someValue)\n  .someChainableMethod(function (value, next) {\n    next(null, value + 's');\n  }, function (err, arg1) {\n    // arg1 == value + 's'\n  })\n  .someOtherMethod(function (value, next) {\n    next(null);\n  }, function (err) {\n    // err == null\n  })\n```\n\n## Run Tests\n\n```\nnpm install\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/scottcorgan/series.git"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha test/ --reporter spec"
  },
  "version": "0.3.3"
}
